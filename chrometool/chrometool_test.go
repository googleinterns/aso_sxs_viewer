package chrometool

import (
	"bufio"
	"bytes"
	"context"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"net"
	"net/http"
	"os"
	"strings"
	"testing"
	"time"

	"github.com/chromedp/chromedp"
	"github.com/gobwas/ws"
	"github.com/gobwas/ws/wsutil"
)

type requestType struct {
	method string
	params string
}

type responseType struct {
	index        int
	responseList [][]byte
}

var (
	testServerPort = flag.Int("port", 8600, "test server port")
	mockChromePort = flag.Int("mock_chrome_port", 0, "mock chrome port")
	wsURL          = flag.String("chrome_ws_url", "", "chrome's web socket URL")

	//run the test server to generate the log file
	runTestServer = flag.Bool("run_test_server", false, "run a test http server")

	//requestFile and responseFile may be generated by the following command
	// $ mkfifo one
	// $ websocat -s {mockChromePort} < one | tee /dev/tty | websocat {chrome's wsURL} | tee one
	logFile = "testdata/log.txt"
)

func TestChromeTool(t *testing.T) {
	flag.Parse()
	portCh := make(chan string)

	if *runTestServer {
		go testServer(t, fmt.Sprintf(":%d", *testServerPort))
	}
	go mockChrome(t, fmt.Sprintf(":%d", *mockChromePort), logFile, portCh)

	select {
	case <-time.After(10 * time.Second):
		t.Errorf("reached timeout: conn not established")
	case mockChromePort := <-portCh:
		if *wsURL == "" {
			*wsURL = "ws://127.0.0.1" + mockChromePort
		}
	}

	flagDevToolWsURL := flag.String("devtools-ws-url", *wsURL, "DevTools WebSsocket URL")
	flag.Parse()
	if *flagDevToolWsURL == "" {
		t.Errorf("must specify -devtools-ws-url")
	}
	allocatorContext, cancel := chromedp.NewRemoteAllocator(context.Background(), *flagDevToolWsURL)
	defer cancel()

	// create context
	ctx, cancel := chromedp.NewContext(allocatorContext)
	defer cancel()

	// run task list
	var val1, val2 string
	err := chromedp.Run(ctx, sendActions(fmt.Sprintf("http://localhost:%d", *testServerPort), &val1, &val2))
	if err != nil {
		t.Errorf("Encountered error %s in Run()", err.Error())
	}

	want := "textarea1test1"
	got := val1
	if got != want {
		t.Errorf("Got text = %q, want %q", got, want)
	}

	want = "Click button 1"
	got = val2
	if got != want {
		t.Errorf("Got text = %q, want %q", got, want)
	}
}

// sendActions sends actions to the server and extracts 4 values from the html page.
func sendActions(host string, val1, val2 *string) chromedp.Tasks {
	return chromedp.Tasks{
		chromedp.Navigate(host),
		ClickNthElement(NthChildSel{`.keystest`, 1}, chromedp.ByQueryAll),
		SendKeysToNthElement(NthChildSel{`.keystest`, 1}, "test1"),
		chromedp.Value(`#textarea1`, val1, chromedp.ByID),
		ClickNthElement(NthChildSel{`.clicktest`, 1}, chromedp.ByQueryAll),
		chromedp.InnerHTML(`#p2`, val2, chromedp.ByID),
	}
}

func mockChrome(t *testing.T, addr string, logFile string, portCh chan string) {
	var err error

	responseMap, err := populateResponses(logFile)
	if err != nil {
		t.Errorf("Encountered error %s in populateResponses()", err.Error())
		return
	}

	listener, err := net.Listen("tcp", addr)
	if err != nil {
		t.Errorf("Encountered error %s in net.Listen()", err.Error())
	}

	Addr := strings.Split(listener.Addr().String(), ":")
	port := Addr[len(Addr)-1]
	port = ":" + port
	portCh <- port

	conn, err := listener.Accept()
	if err != nil {
		t.Errorf("Encountered error %s in listner.Accept()", err.Error())
	}

	upgrader := ws.Upgrader{}
	if _, err := upgrader.Upgrade(conn); err != nil {
		t.Errorf("Encountered error %s in upgrader.Upgrade()", err.Error())
	}

	for {
		var request map[string]interface{}

		data, op, err := wsutil.ReadData(conn, ws.StateServerSide)
		if err != nil {
			if err == io.EOF {
				break
			}
			t.Errorf("Encountered error %s in wsReadData()", err.Error())
			break
		}

		json.Unmarshal(data, &request)
		responseType, ok := responseMap[newRequestType(request)]
		if !ok {
			t.Errorf("Could not find appropriate response for request %s", string(data))
			return
		}
		ctr := responseType.index
		responseType.index++
		responseMap[newRequestType(request)] = responseType
		if ctr >= len(responseType.responseList) {
			ctr = len(responseType.responseList) - 1
		}

		scanner := bufio.NewScanner(bytes.NewReader(responseType.responseList[ctr]))
		for scanner.Scan() {
			serverData := scanner.Bytes()
			var response map[string]interface{}

			json.Unmarshal(scanner.Bytes(), &response)
			if _, ok := response["id"]; ok {
				responseID := "\"id\":" + fmt.Sprintf("%v", response["id"])
				requestID := "\"id\":" + fmt.Sprintf("%v", request["id"])
				serverText := strings.Replace(scanner.Text(), responseID, requestID, 1)
				serverData = []byte(serverText)
			}

			// The delay here is intentional to avoid race conditions that chromedp sometimes encounters
			// removing this may lead test to hang and timeout
			// TODO: ensure prevention of such race conditions at upstream
			time.Sleep(1 * time.Millisecond)
			wsutil.WriteMessage(conn, ws.StateServerSide, op, serverData)
		}
	}
}

func populateResponses(log string) (map[requestType]responseType, error) {
	responseMap := make(map[requestType]responseType)

	logFile, err := os.Open(log)
	if err != nil {
		return nil, err
	}

	defer func() {
		logFile.Close()
	}()

	scanner := bufio.NewScanner(logFile)
	var serverData []byte
	var prevRequestType requestType
	IDmap := make(map[interface{}]requestType)

	//populate prevRequestType
	for scanner.Scan() {
		var entry map[string]interface{}
		json.Unmarshal(scanner.Bytes(), &entry)
		if id, ok := entry["id"]; ok {
			IDmap[id] = newRequestType(entry)
			prevRequestType = newRequestType(entry)
			break
		}
	}

	for scanner.Scan() {
		var entry map[string]interface{}

		json.Unmarshal(scanner.Bytes(), &entry)
		if id, ok := entry["id"]; ok {
			if reqType, isPresent := IDmap[id]; isPresent {
				line := append(scanner.Bytes(), '\n')
				serverData = append(serverData, line...)
				if resType, isPres := responseMap[reqType]; isPres {
					resType.responseList = append(resType.responseList, serverData)
					responseMap[reqType] = resType
				} else {
					responseMap[reqType] = newResponseType(serverData)
				}
				prevRequestType = reqType
				delete(IDmap, id)
			} else {
				resType := responseMap[prevRequestType]
				resList := resType.responseList
				resList[len(resList)-1] = append(resList[len(resList)-1], serverData...)
				resType.responseList = resList
				responseMap[prevRequestType] = resType
				IDmap[id] = newRequestType(entry)
			}
			serverData = nil
			continue
		}
		line := append(scanner.Bytes(), '\n')
		serverData = append(serverData, line...)
	}
	err = scanner.Err()
	return responseMap, err
}

func newResponseType(response []byte) responseType {
	var responses [][]byte
	res := responseType{
		responseList: append(responses, response),
	}
	return res
}

func newRequestType(request map[string]interface{}) requestType {
	req := requestType{}
	if method, ok := request["method"]; ok {
		reqMethod, err := json.Marshal(method)
		if err != nil {
			fmt.Println(err)
		}
		req.method = string(reqMethod)
	}
	if params, ok := request["params"]; ok {
		reqParams, err := json.Marshal(params)
		if err != nil {
			fmt.Println(err)
		}
		req.params = string(reqParams)
	}
	return req
}

// testServer is a simple HTTP server that displays the passed headers in the html.
func testServer(t *testing.T, addr string) error {
	mux := http.NewServeMux()
	mux.HandleFunc("/", func(res http.ResponseWriter, _ *http.Request) {
		fmt.Fprint(res, indexHTML)
	})
	return http.ListenAndServe(addr, mux)
}

const indexHTML = `<!doctype html>
<html>
<head>
  <title>test</title>
</head>
<body>
  <div id="box1">   
    <p id="p1">
	  <textarea id="textarea0" class="keystest" style="width:500px;height:400px">textarea0</textarea><br><br>
	  <textarea id="textarea1" class="keystest" style="width:500px;height:400px">textarea1</textarea><br><br>
	  <textarea id="textarea2" class="keystest" style="width:500px;height:400px">textarea2</textarea><br><br>
    </p>
  </div>
  <div id="box2">
  	<p id="p2">para2</p> 
	  <input type='button' class="clicktest" onclick='changeText0()' value='Change Text 0'/>
	  <input type='button' class="clicktest" onclick='changeText1()' value='Change Text 1'/>
	  <input type='button' class="clicktest" onclick='changeText2()' value='Change Text 2'/>
  </div>
<script>
function changeText0()
{
 document.getElementById('p2').innerHTML = 'Click button 0';
}
function changeText1()
{
 document.getElementById('p2').innerHTML = 'Click button 1';
}
function changeText2()
{
 document.getElementById('p2').innerHTML = 'Click button 2';
}
</script>
</body>
</html>`
